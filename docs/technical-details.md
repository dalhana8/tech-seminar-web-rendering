# ISR (Incremental Static Regeneration) 상세 설명

## 📚 목차
- [정의](#정의)
- [등장 배경](#등장-배경)  
- [동작 과정](#동작-과정)
- [장단점 비교](#장단점-비교)
- [실제 적용 사례](#실제-적용-사례)
- [예상 질문](#예상-질문-리스트)
- [참고 자료](#참조-사이트)

## 🎯 정의 
ISR은 SSG의 성능 이점과 동적 콘텐츠 업데이트의 유연성을 결합한 하이브리드 웹 렌더링 전략이다. 콘텐츠가 변경될 때 전체 사이트를 재구축하는 대신, ISR을 사용하면 개별 페이지를 백그라운드에서 필요에 따라 재생성하는 동시에 캐시된 정적 버전을 사용자에게 즉시 제공할 수 있다. 

이 "stale-while-revalidate" 방식은 사용자에게 항상 빠른 로딩 속도의 페이지를 제공하지만, 콘텐츠는 구성할 수 있는 재검증 간격 또는 트리거에 따라 자동으로 업데이트될 수 있음을 의미한다. 2020년 Next.js를 통해 처음 대중화된 ISR은 정적 성능과 동적 최신성 간의 전통적인 상충 관계를 해결하여 콘텐츠가 자주 변경되지만, 빠른 로딩 시간이 중요한 전자상거래 플랫폼, 블로그, 뉴스 사이트와 같은 사이트가 이상적이다.

## 📈 등장 배경

SSG는 사전 구축된 페이지를 통해 뛰어난 성능을 제공했지만, 콘텐츠를 변경하면 전체 사이트를 다시 빌드하고 배포해야 한다는 큰 단점이 있었다. ISR은 SSG의 한계를 극복하기 위한 해결책으로 2020년 7월(Next.js는 9.5 버전) 등장했다. 

## 🔄 동작 과정

![ISR](https://blog.kakaocdn.net/dna/bApTpt/btrPRd3X5nX/AAAAAAAAAAAAAAAAAAAAAI-0wUSgs6GBRSruPR9T1UJt3ucCNR7sBaxvCcZac3ys/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=g8YmgQgVneke8KJZJVv87qZ%2BD0M%3D)

1. 빌드: 지정된 경로에 대한 정적 HTML 페이지 생성, 재검증 규칙 설정(시간 간격 또는 주문형 트리거) 그리고 정적 자산을 CDN/호스트 플랫폼에 배포한다.
2. 첫 번째 요청: 클라이언트가 페이지를 요청하면 서버가 정적 버전이 존재하는지 확인한 후 캐시된 HTML을 즉시 제공(빠른 응답) 마지막 생성 시간의 타임스탬프 기록한다.
3. 유효성 확인: 다음 요청에서는 현재 시각과 마지막 생성 시간을 비교한다. 재검증 기간 내면 캐시된 버전을 제공하고 재검증 기간이 지나면 기존 캐시된 버전을 제공하는 동안 백그라운드에서 재생성을 트리거 한다.
4. 백그라운드 재생성: API/데이터베이스에서 새 데이터를 가져와 페이지 생성 프로세스 다시 실행하고 새 정적 HTML 버전 생성해 최신 콘텐츠로 캐시 업데이트한다.
5. 캐시 업데이트: 기존의 정적 파일을 새 버전으로 교체하고 검증 타이머를 재설정한다. 이후 요청은 업데이트된 콘텐츠를 제공받는다.
6. 폴백 핸들링: 빌드 시 사전 생성되지 않은 페이지의 경우 첫 번째 요청 시 정적 버전 생성하고 이후 요청에 대해서는 캐시를 활용하며 동일한 재검증 주기를 따른다.

## ⚖️ 장단점 비교

| 장점 ✅ | 단점 ❌ |
|---------|---------|
| 빠른 페이지 로딩 | 실시간 데이터 제한 |
| SEO 최적화 | 개인화 콘텐츠 어려움 |
| 보안성 우수 | 복잡한 캐시 관리 |
| CDN 활용 가능 | 초기 방문자 구버전 경험 |
| 자동 콘텐츠 갱신 | 빌드 비용 증가 |

## 🌐 실제 적용 사례

### 적합한 서비스
- 📰 뉴스 사이트 (정기적 콘텐츠 업데이트)
- 🛒 이커머스 (상품 정보 변경)
- 📝 블로그 (새 포스트 추가)

### 부적합한 서비스  
- 💬 실시간 채팅
- 📊 실시간 대시보드
- 🔐 개인화 계정 페이지

## ❓예상 질문 리스트
Q. SSG랑 ISR에서 보여준 페이지 소스 보기 코드는 SSR에서도 볼 수 있는 것 아닌가요? 세 개 다 서버에서 받아오는 거잖아요.

R. SSG, ISR, SSR 모두 서버에서 완성된 HTML을 받아오기 때문에 페이지 소스 보기를 하면 실제로 렌더링 된 콘텐츠가 다 보입니다. 크롤러 입장에서도 세 방식 모두 완성된 HTML을 받을 수 있으니까 SEO 측면에서는 비슷하다고 볼 수 있습니다. 차이점은 언제 그 HTML이 만들어지느냐에 있습니다. SSG는 빌드 시점에 미리 다 만들어놔서 요청이 오면 바로 파일을 던져주는 거고, ISR은 SSG + 필요할 때 백그라운드에서 다시 만드는 거고, SSR은 요청이 올 때마다 그때그때 만듭니다. 그래서 페이지 소스 보기 결과물은 비슷해 보이지만 SSG와 ISR는 정적 파일이니까 CDN에서 바로 전송, 엄청 빠르고 SSR 서버에서 매번 연산해서 만들어야 하니까 상대적으로 느립니다.

Q. SSR에서 서버가 HTML을 만들어 보낸 후 JS가 연결되는 과정에서, 만약 네트워크가 느려서 JS 로딩이 지연되면 어떤 현상이 일어나요?

R. HTML은 서버에서 완성된 상태로 오기 때문에 화면에는 모든 콘텐츠가 정상적으로 보이지만 JavaScript가 아직 로드되지 않았기 때문에 버튼을 클릭해도 아무 반응이 없고, 폼에 입력을 해도 작동하지 않습니다. 서버에서 온 정적인 HTML에 JavaScript 이벤트들을 연결하는 과정을 하이드레이션이라고 합니다. 그래서 JS 로딩이 지연되면 하이드레이션도 지연됩니다. 구현 페이지에서 보여드린 것처럼, Disable JavaScript를 체크했을 때 콘텐츠는 보이지만 상호작용이 안 되는 것과 같은 상황입니다. 결국 사이트가 제대로 동작하지 않기 때문에 사용자에게 불편함을 줍니다. 그래서 SSR을 할 때는 중요한 JavaScript부터 우선 로드되도록 최적화하거나, 아니면 로딩 중이라는 걸 사용자에게 알려주는 것이 중요합니다.

Q. CSR에서 SEO 문제를 해결하려면 어떤 방법들이 있나요?

R. 첫 번째는 프리렌더링이 있습니다. Puppeteer 같은 도구로 미리 페이지를 렌더링해서 완성된 HTML을 만들어 둘 수 있습니다.
두 번째는 다이나믹 렌더링으로 일반 사용자한테는 CSR로 서비스하고 크롤러가 오면 따로 SSR 버전을 보여주는 방식입니다.
그리고 React Helmet 같은 라이브러리로 메타 태그를 동적으로 관리할 수도 있고, sitemap.xml을 만들어서 크롤러에 페이지 구조를 알려주는 것도 도움이 됩니다.

## 🔗 참조 사이트 

1. https://velog.io/@codns1223/Nextjs-ISR-Incremental-Static-Regeneration%EC%9D%B4%EB%9E%80

2. https://medium.com/@ignatovich.dm/incremental-static-regeneration-isr-keeping-your-pages-fresh-and-fast-f28933c28e54

3. https://nextjs.org/docs/pages/guides/incremental-static-regeneration 

4. https://nextjs.org/docs/13/pages/building-your-application/rendering/incremental-static-regeneration

5. https://vercel.com/docs/incremental-static-regeneration

