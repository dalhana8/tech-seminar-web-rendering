# ISR (Incremental Static Regeneration) 상세 설명

![ISR](https://blog.kakaocdn.net/dna/bApTpt/btrPRd3X5nX/AAAAAAAAAAAAAAAAAAAAAI-0wUSgs6GBRSruPR9T1UJt3ucCNR7sBaxvCcZac3ys/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=g8YmgQgVneke8KJZJVv87qZ%2BD0M%3D)

## 정의 
ISR은 SSG의 성능 이점과 동적 콘텐츠 업데이트의 유연성을 결합한 하이브리드 웹 렌더링 전략이다. 콘텐츠가 변경될 때 전체 사이트를 재구축하는 대신, ISR을 사용하면 개별 페이지를 백그라운드에서 필요에 따라 재생성하는 동시에 캐시된 정적 버전을 사용자에게 즉시 제공할 수 있다. 이 "stale-while-revalidate" 방식은 사용자에게 항상 빠른 로딩 속도의 페이지를 제공하지만, 콘텐츠는 구성할 수 있는 재검증 간격 또는 트리거에 따라 자동으로 업데이트될 수 있음을 의미한다. 2020년 Next.js를 통해 처음 대중화된 ISR은 정적 성능과 동적 최신성 간의 전통적인 상충 관계를 해결하여 콘텐츠가 자주 변경되지만, 빠른 로딩 시간이 중요한 전자상거래 플랫폼, 블로그, 뉴스 사이트와 같은 사이트가 이상적이다.

## 등장 배경

SSG는 사전 구축된 페이지를 통해 뛰어난 성능을 제공했지만, 콘텐츠를 변경하면 전체 사이트를 다시 빌드하고 배포해야 한다는 큰 단점이 있었다. ISR은 SSG의 한계를 극복하기 위한 해결책으로 2020년 7월(Next.js는 9.5 버전) 등장했다. 

## 동작 과정

1. 빌드: 지정된 경로에 대한 정적 HTML 페이지 생성, 재검증 규칙 설정(시간 간격 또는 주문형 트리거) 그리고 정적 자산을 CDN/호스트 플랫폼에 배포한다.
2. 첫 번째 요청: 클라이언트가 페이지를 요청하면 서버가 정적 버전이 존재하는지 확인한 후 캐시된 HTML을 즉시 제공(빠른 응답) 마지막 생성 시간의 타임스탬프 기록한다.
3. 유효성 확인: 다음 요청에서는 현재 시각과 마지막 생성 시간을 비교한다. 재검증 기간 내인 겨우 캐시된 버전을 제공하고 재검증 기간이 지나면 기존 캐시된 버전을 제공하는 동안 백그라운드에서 재생성을 트리거한다.
4. 백그라운드 재생성: API/데이터베이스에서 새 데이터를 가져와 페이지 생성 프로세스 다시 실행하고 새 정적 HTML 버전 생성해 최신 콘텐츠로 캐시 업데이트한다.
5. 캐시 업데이트: 기존의 정적 파일을 새 버전으로 교체하고 검증 타이머를 재설정한다. 이후 요청은 업데이트된 콘텐츠를 제공받는다.
6. 폴백 핸들링: 빌드 시 사전 생성되지 않은 페이지의 경우 첫 번째 요청 시 정적 버전 생성하고 이후 요청에 대해서는 캐시를 활용하며 동일한 재검증 주기를 따른다.

## 장점

1. 페이지 로딩 시간이 빠름
    - 정적 파일로 미리 생성되어 서버 처리 시간 없이 즉시 제공
    - CDN을 통해 사용자와 가장 가까운 위치에서 파일 전송
2. 자바스크립트 필요 X
    - 서버에서 완전히 렌더링 된 HTML을 제공하여 클라이언트 처리 불필요
    - 저성능 디바이스나 느린 네트워크 환경에서도 빠른 콘텐츠 표시
3. SEO 최적화가 좋다
    - 검색 엔진 크롤러가 완성된 HTML 콘텐츠에 즉시 접근 가능
    - 메타 태그와 구조화된 데이터가 사전에 렌더링 되어 있음
4. 보안이 뛰어나다
    - 정적 파일로만 구성되어 서버 취약점 공격 벡터 최소화
    - 데이터베이스 직접 노출 위험성 제거
5. CDN 캐시가 된다
    - 전 세계 CDN 노드에 콘텐츠 분산 저장
    - 글로벌 사용자에게 일관되게 빠른 성능 제공
6. 데이터가 주기적으로 업데이트 
    - 설정된 주기에 따라 백그라운드에서 자동 콘텐츠 갱신
    - 수동 배포 없이도 최신 데이터 반영

## 단점

1. 데이터가 주기적으로 업데이트 되지만 이 또한 실시간 데이터가 아님
    - 콘텐츠 변경과 실제 반영 사이에 지연 시간 존재
    - 실시간성이 중요한 금융, 뉴스, 채팅 등의 서비스에는 부적합
2. 사용자별 정보 제공이 여전히 어려움
    - 개인화된 콘텐츠나 사용자 맞춤 데이터 표시의 제약
    - 로그인 상태, 개인 설정, 장바구니 등 동적 사용자 데이터 처리 한계
3. 복잡한 캐시 관리가 필요
    - 페이지별 재생성 주기 설정 및 관리 복잡성
    - 캐시 무효화 전략 수립 및 구현의 어려움
4. 초기 방문자는 구버전을 경험할 수 있다
    - 새로 생성되거나 업데이트된 페이지의 첫 방문 시 이전 버전 노출 가능
    - 콘텐츠 일관성 보장의 어려움
5. 빌드 시간과 비용이 증가할 수 있다
    - 대규모 사이트의 경우 백그라운드 재생성으로 인한 서버 리소스 사용
    - 페이지 수가 많을수록 관리 복잡도 증가

# 예상 질문 리스트
Q. SSG랑 ISR에서 보여준 페이지 소스 보기 코드는 SSR에서도 볼 수 있는 것 아닌가요? 세 개 다 서버에서 받아오는 거잖아요.

R. SSG, ISR, SSR 모두 서버에서 완성된 HTML을 받아오기 때문에 페이지 소스 보기를 하면 실제로 렌더링 된 콘텐츠가 다 보입니다. 크롤러 입장에서도 세 방식 모두 완성된 HTML을 받을 수 있으니까 SEO 측면에서는 비슷하다고 볼 수 있습니다. 차이점은 언제 그 HTML이 만들어지느냐에 있습니다. SSG는 빌드 시점에 미리 다 만들어놔서 요청이 오면 바로 파일을 던져주는 거고, ISR은 SSG + 필요할 때 백그라운드에서 다시 만드는 거고, SSR은 요청이 올 때마다 그때그때 만듭니다. 그래서 페이지 소스 보기 결과물은 비슷해 보이지만 SSG와 ISR는 정적 파일이니까 CDN에서 바로 전송, 엄청 빠르고 SSR 서버에서 매번 연산해서 만들어야 하니까 상대적으로 느립니다.

Q. CSR이 보안에 취약하다고 하셨는데, 다른 방법들은 어떤가요?

R. SSG, ISR은 정적 파일이라서 정보 노출이 안 되게 잘 관리해야 할 것 같고, SSR은 서버 부하 공격 같은 걸 당할 수 있어서 각자의 약점이 될 수 있는 부분을 신경 써야 할 것 같습니다.

Q. SSR에서 서버가 HTML을 만들어 보낸 후 JS가 연결되는 과정에서, 만약 네트워크가 느려서 JS 로딩이 지연되면 어떤 현상이 일어나요?

R. HTML은 서버에서 완성된 상태로 오기 때문에 화면에는 모든 콘텐츠가 정상적으로 보이지만 JavaScript가 아직 로드되지 않았기 때문에 버튼을 클릭해도 아무 반응이 없고, 폼에 입력을 해도 작동하지 않습니다. 서버에서 온 정적인 HTML에 JavaScript 이벤트들을 연결하는 과정을 하이드레이션이라고 합니다. 그래서 JS 로딩이 지연되면 하이드레이션도 지연됩니다. 구현페이지에서 보여드린 것처럼, Disable JavaScript를 체크했을 때 콘텐츠는 보이지만 상호작용이 안 되는 것과 같은 상황입니다. 결국 사이트가 제대로 동작하지 않기 때문에 사용자에게 불편함을 줍니다. 그래서 SSR을 할 때는 중요한 JavaScript부터 우선 로드되도록 최적화하거나, 아니면 로딩 중이라는 걸 사용자에게 알려주는 것이 중요합니다.

Q. SEO에 제일 유리한 건 어떤 방식인가요?

R. SSG > SSR > ISR > CSR 순 / 이유는 HTML이 정적으로 존재할수록 검색엔진이 더 잘 인식할 수 있기 때문입니다.

Q. 정적 페이지들은 보안 측면에서 더 안전한가요?

R. 네, 맞습니다. SSG나 ISR은 정적 파일만 배포되므로 서버 로직이 노출되지 않아 **보안에 유리**합니다. **서버리스 구조**이기 때문에 공격 표면도 줄어요.

Q. CSR에서 SEO 문제를 해결하려면 어떤 방법들이 있나요?

R. 첫 번째는 프리렌더링이 있습니다. Puppeteer 같은 도구로 미리 페이지를 렌더링해서 완성된 HTML을 만들어 둘 수 있습니다.
두 번째는 다이나믹 렌더링으로 일반 사용자한테는 CSR로 서비스하고 크롤러가 오면 따로 SSR 버전을 보여주는 방식입니다.
그리고 React Helmet 같은 라이브러리로 메타 태그를 동적으로 관리할 수도 있고, sitemap.xml을 만들어서 크롤러에 페이지 구조를 알려주는 것도 도움이 됩니다.





# 참조 사이트 

1. https://velog.io/@codns1223/Nextjs-ISR-Incremental-Static-Regeneration%EC%9D%B4%EB%9E%80

2. https://medium.com/@ignatovich.dm/incremental-static-regeneration-isr-keeping-your-pages-fresh-and-fast-f28933c28e54

3. https://nextjs.org/docs/pages/guides/incremental-static-regeneration 

4. https://nextjs.org/docs/13/pages/building-your-application/rendering/incremental-static-regeneration

5. https://vercel.com/docs/incremental-static-regeneration